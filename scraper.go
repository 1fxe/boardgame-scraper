// scraper
package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"github.com/1fxe/board-game-web-scraper/internal"
	"github.com/chromedp/chromedp"
	"github.com/gocolly/colly"
	"log"
	"os"
	"strings"
)

type TableConfig struct {
	CategoryURL     string `json:"categoriesURL"`
	MechanicsURL    string `json:"mechanicsURL"`
	Table           string `json:"table"`
	ItemName        string `json:"itemName"`
	ItemDescription string `json:"itemDescription"`
}

type Config struct {
	Domain      string      `json:"domain"`
	CreditsURL  string      `json:"creditsURL"`
	TableConfig TableConfig `json:"tableConfig"`
}

type URLforParsing struct {
	URL string `json:"url"`
}

type AutoGenerated struct {
	Item struct {
		Itemdata []struct {
			Datatype        string `json:"datatype,omitempty"`
			Fieldname       string `json:"fieldname,omitempty"`
			Title           string `json:"title,omitempty"`
			Primaryname     bool   `json:"primaryname,omitempty"`
			Required        bool   `json:"required,omitempty"`
			Unclickable     bool   `json:"unclickable,omitempty"`
			Fullcredits     bool   `json:"fullcredits,omitempty"`
			Subtype         string `json:"subtype,omitempty"`
			Keyname         string `json:"keyname,omitempty"`
			Alternate       bool   `json:"alternate,omitempty"`
			OtherObjecttype string `json:"other_objecttype,omitempty"`
			OtherSubtype    string `json:"other_subtype,omitempty"`
			LookupSubtype   string `json:"lookup_subtype,omitempty"`
			Linktype        string `json:"linktype,omitempty"`
			SelfPrefix      string `json:"self_prefix,omitempty"`
		} `json:"itemdata,omitempty"`
		Relatedlinktypes []interface{} `json:"relatedlinktypes,omitempty"`
		LinkedforumTypes []struct {
			Title            string      `json:"title,omitempty"`
			LinkedforumIndex string      `json:"linkedforum_index,omitempty"`
			LinkdataIndex    string      `json:"linkdata_index,omitempty"`
			RequiredSubtype  interface{} `json:"required_subtype,omitempty"`
		} `json:"linkedforum_types,omitempty"`
		Subtypename string `json:"subtypename,omitempty"`
		Stats       struct {
			Playmonth     string `json:"playmonth,omitempty"`
			Numplays      int    `json:"numplays,omitempty"`
			NumplaysMonth int    `json:"numplays_month,omitempty"`
			Numfans       int    `json:"numfans,omitempty"`
		} `json:"stats,omitempty"`
		Relatedcounts struct {
			News    int `json:"news,omitempty"`
			Blogs   int `json:"blogs,omitempty"`
			Weblink int `json:"weblink,omitempty"`
			Podcast int `json:"podcast,omitempty"`
		} `json:"relatedcounts,omitempty"`
		Itemid      int      `json:"itemid,omitempty"`
		Objecttype  string   `json:"objecttype,omitempty"`
		Objectid    int      `json:"objectid,omitempty"`
		Label       string   `json:"label,omitempty"`
		Labelpl     string   `json:"labelpl,omitempty"`
		Type        string   `json:"type,omitempty"`
		ID          string   `json:"id,omitempty"`
		Href        string   `json:"href,omitempty"`
		Subtype     string   `json:"subtype,omitempty"`
		Subtypes    []string `json:"subtypes,omitempty"`
		Versioninfo struct {
			Gamepageorderurl interface{} `json:"gamepageorderurl,omitempty"`
			Shopifyitem      interface{} `json:"shopifyitem,omitempty"`
		} `json:"versioninfo,omitempty"`
		Name          string      `json:"name,omitempty"`
		Alternatename interface{} `json:"alternatename,omitempty"`
		Links         struct {
			Boardgame []struct {
				Name        string `json:"name,omitempty"`
				Objecttype  string `json:"objecttype,omitempty"`
				Objectid    string `json:"objectid,omitempty"`
				Primarylink int    `json:"primarylink,omitempty"`
				Itemstate   string `json:"itemstate,omitempty"`
				Href        string `json:"href,omitempty"`
			} `json:"boardgame,omitempty"`
		} `json:"links,omitempty"`
		Linkcounts struct {
			Boardgame int `json:"boardgame,omitempty"`
		} `json:"linkcounts,omitempty"`
		Secondarynamescount int `json:"secondarynamescount,omitempty"`
		Alternatenamescount int `json:"alternatenamescount,omitempty"`
		Primaryname         struct {
			Nameid      string `json:"nameid,omitempty"`
			Name        string `json:"name,omitempty"`
			Sortindex   string `json:"sortindex,omitempty"`
			Primaryname string `json:"primaryname,omitempty"`
			Translit    string `json:"translit,omitempty"`
		} `json:"primaryname,omitempty"`
		Alternatenames []interface{} `json:"alternatenames,omitempty"`
		Description    string        `json:"description,omitempty"`
		Wiki           string        `json:"wiki,omitempty"`
		Website        struct {
			URL bool `json:"url,omitempty"`
		} `json:"website,omitempty"`
		Imageid string `json:"imageid,omitempty"`
		Images  struct {
			Thumb        string `json:"thumb,omitempty"`
			Micro        string `json:"micro,omitempty"`
			Square       string `json:"square,omitempty"`
			Squarefit    string `json:"squarefit,omitempty"`
			Tallthumb    string `json:"tallthumb,omitempty"`
			Previewthumb string `json:"previewthumb,omitempty"`
			Square200    string `json:"square200,omitempty"`
		} `json:"images,omitempty"`
		Imagepagehref string `json:"imagepagehref,omitempty"`
		Imageurl      string `json:"imageurl,omitempty"`
		ImageSets     struct {
			Square100 struct {
				Src   string `json:"src,omitempty"`
				Src2X string `json:"src@2x,omitempty"`
			} `json:"square100,omitempty"`
			Mediacard struct {
				Src   string `json:"src,omitempty"`
				Src2X string `json:"src@2x,omitempty"`
			} `json:"mediacard,omitempty"`
		} `json:"imageSets,omitempty"`
		Itemstate   string      `json:"itemstate,omitempty"`
		PromotedAd  interface{} `json:"promoted_ad,omitempty"`
		SpecialUser interface{} `json:"special_user,omitempty"`
	} `json:"item,omitempty"`
	Media struct {
		Files struct {
			Numitems string `json:"numitems,omitempty"`
		} `json:"files,omitempty"`
		Images struct {
			Numitems int `json:"numitems,omitempty"`
		} `json:"images,omitempty"`
		Videos struct {
			Numitems int `json:"numitems,omitempty"`
		} `json:"videos,omitempty"`
	} `json:"media,omitempty"`
	Videogalleries struct {
		Galleries []struct {
			Type string `json:"type,omitempty"`
			Name string `json:"name,omitempty"`
		} `json:"galleries,omitempty"`
	} `json:"videogalleries,omitempty"`
}

type Scraper struct {
	config    Config
	ctx       context.Context
	collector *colly.Collector
}

func (s Scraper) getDataFromTable(table string) {
	var urls []URLforParsing

	s.collector.OnHTML(s.config.TableConfig.Table, func(e *colly.HTMLElement) {
		e.ForEach("tr", func(_ int, e *colly.HTMLElement) {
			e.ForEach("td", func(_ int, e *colly.HTMLElement) {
				href := e.ChildAttr("a", "href")
				if href != "" {
					link := fmt.Sprintf("https://%s%s", s.config.Domain, href)
					urls = append(urls, URLforParsing{link})
				}
			})
		})
	})

	if table == internal.CategoriesURLS {
		_ = s.collector.Visit(s.config.TableConfig.CategoryURL)
	} else if table == internal.MechanicsURLS {
		_ = s.collector.Visit(s.config.TableConfig.MechanicsURL)
	}

	file, err := json.MarshalIndent(urls, "", "   ")
	if err != nil {
		log.Fatalln("Failed to marshal json", urls)
	}
	err = os.WriteFile(fmt.Sprintf("./data/%s.json", table), file, 0644)
	if err != nil {
		log.Fatalln("Failed to write json", file)
	}
}

func (s Scraper) parseFromTableURLs(table string) {
	file, err := os.ReadFile(fmt.Sprintf("./data/%sURLS.json", table))

	if err != nil {
		log.Printf("Error reading %s.json %s", table, err)
		return
	}

	var urlForParsing []URLforParsing

	err = json.Unmarshal(file, &urlForParsing)

	if err != nil {
		log.Printf("Error reading parsing json %s", err)
		return
	}

	log.Println("Started Parsing URLS")
	var data []internal.Data

	s.collector.OnXML(s.config.TableConfig.ItemName, func(e *colly.XMLElement) {
		s := strings.Split(e.Text, "GEEK.geekitemPreload = ")[1]
		s = strings.Split(s, "GEEK.geekitemSettings = ")[0]
		s = strings.TrimSpace(s)
		s = strings.TrimSuffix(s, ";")
		var autoGen AutoGenerated
		_ = json.Unmarshal([]byte(s), &autoGen)

		log.Println(autoGen.Item.Name)

		// TODO Improve this
		cleanDescription := strings.Split(autoGen.Item.Description, "/em> ")
		if len(cleanDescription) > 1 {
			data = append(data, internal.Data{Name: autoGen.Item.Name, Description: cleanDescription[1]})
		} else {
			data = append(data, internal.Data{Name: autoGen.Item.Name, Description: cleanDescription[0]})
		}
	})

	for _, url := range urlForParsing {
		_ = s.collector.Visit(url.URL)
	}

	log.Println("Finished Parsing URLS")

	out, err := json.MarshalIndent(data, "", "   ")
	if err != nil {
		log.Fatalln("Failed to marshal json", data)
	}
	err = os.WriteFile(fmt.Sprintf("./data/%s.json", table), out, 0644)
	if err != nil {
		log.Fatalln("Failed to write json", out)
	}
}

func main() {

	getCategories := flag.Bool("getCategories", false, "Gets list of categories for future parsing")
	parseCategories := flag.Bool("parseCategories", false, "Parse categories from list")

	getMechanics := flag.Bool("getMechanics", false, "Gets list of mechanism for future parsing")
	parseMechanics := flag.Bool("parseMechanics", false, "Parse mechanisms from list")

	flag.Parse()

	cfgFile, err := os.ReadFile("config.json")

	if err != nil {
		log.Printf("Error reading config.json %s", err)
		return
	}

	cfg := Config{}

	err = json.Unmarshal(cfgFile, &cfg)

	if err != nil {
		log.Printf("Error parsing json %s", err)
		return
	}

	log.Println("Successfully loaded config:", cfg)

	if err := os.Mkdir("data", os.ModePerm); err != nil {
		log.Println(err)
	}

	options := append(chromedp.DefaultExecAllocatorOptions[:],
		// block all images
		chromedp.Flag("blink-settings", "imagesEnabled=false"),
	)
	allocatorCtx, cancel := chromedp.NewExecAllocator(context.Background(), options...)
	defer cancel()

	ctx, cancel := chromedp.NewContext(allocatorCtx)
	defer cancel()

	collector := colly.NewCollector(
		colly.AllowedDomains(cfg.Domain),
	)

	collector.OnError(func(_ *colly.Response, err error) {
		log.Println("Something went wrong:", err)
	})

	collector.OnResponse(func(r *colly.Response) {
		log.Println("Visited", r.Request.URL)
	})

	scraper := Scraper{cfg, ctx, collector}

	if *getCategories {
		scraper.getDataFromTable(internal.CategoriesURLS)
	}

	if *parseCategories {
		scraper.parseFromTableURLs(internal.Categories)
	}

	if *getMechanics {
		scraper.getDataFromTable(internal.MechanicsURLS)
	}

	if *parseMechanics {
		scraper.parseFromTableURLs(internal.Mechanics)
	}

}
